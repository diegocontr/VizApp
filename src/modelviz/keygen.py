import urllib.parse
import ast # For ast.literal_eval to safely parse string representations of literals

def key_generator(params: dict, preserve_types: bool = False) -> str:
    """
    Generates an order-independent, URL-safe string key from a dictionary of parameters.

    Args:
        params (dict): The dictionary of parameters.
        preserve_types (bool): If True, attempts to preserve basic Python types 
                               (str, int, float, bool, list, dict, tuple, None)
                               by storing their `repr()` string. Otherwise, all values
                               are converted to simple strings using `str()`.

    Returns:
        str: A string key representing the parameters. Returns an empty string
             if the input dictionary is empty.
             
    Raises:
        TypeError: If 'params' is not a dictionary.
    """
    if not isinstance(params, dict):
        raise TypeError("Input 'params' must be a dictionary.")
    if not params:
        return ""  # Return empty string for an empty dictionary

    # Sort items by key to ensure order independence
    sorted_items = sorted(params.items())

    key_parts = []
    for key, value_obj in sorted_items:
        # URL encode the key (converted to string)
        encoded_key = urllib.parse.quote_plus(str(key))
        
        # Convert value to its string representation
        if preserve_types:
            # Use repr() to get a string representation that ast.literal_eval can parse
            value_str_representation = repr(value_obj)
        else:
            value_str_representation = str(value_obj)
        
        # URL encode the string representation of the value
        encoded_value = urllib.parse.quote_plus(value_str_representation)
        
        key_parts.append(f"{encoded_key}={encoded_value}")
        
    return "&".join(key_parts)

def reverse_key_generator(key_string: str, preserved_types: bool = False) -> dict:
    """
    Reverses a string key generated by key_generator back into a dictionary.

    Args:
        key_string (str): The string key to reverse.
        preserved_types (bool): If True, attempts to parse values using 
                                `ast.literal_eval` to restore original types.
                                This should match the 'preserve_types' flag used
                                during key generation.

    Returns:
        dict: The reconstructed dictionary of parameters. Returns an empty
              dictionary if the input string is empty.
              
    Raises:
        TypeError: If 'key_string' is not a string.
        ValueError: If the key_string is malformed or if type restoration fails
                    when 'preserved_types' is True.
    """
    if not isinstance(key_string, str):
        raise TypeError("Input 'key_string' must be a string.")
    if not key_string:
        return {}  # Return empty dictionary for an empty key string

    params = {}
    key_value_pairs = key_string.split('&')

    for pair_str in key_value_pairs:
        if not pair_str:  # Should not happen with non-empty string split by '&' unless '&&'
            continue

        # Split only on the first occurrence of '='
        parts = pair_str.split('=', 1)
        if len(parts) == 2:
            encoded_key, encoded_value_repr = parts
            
            # URL decode key and value representation
            key = urllib.parse.unquote_plus(encoded_key)
            value_str_representation = urllib.parse.unquote_plus(encoded_value_repr)
            
            if preserved_types:
                try:
                    # ast.literal_eval is safer than eval() for evaluating literals
                    value = ast.literal_eval(value_str_representation)
                except (ValueError, SyntaxError, TypeError) as e:
                    # This can happen if the string is not a valid Python literal representation
                    # (e.g., it wasn't generated with repr(), or it's a complex type not supported by ast.literal_eval)
                    raise ValueError(
                        f"Could not evaluate value '{value_str_representation}' for key '{key}'. "
                        f"Ensure it was stored using 'repr()' and is a supported literal type. Original error: {e}"
                    )
            else:
                # Value remains a string (after unquoting)
                value = value_str_representation
            
            params[key] = value
        else:
            # This indicates a malformed pair (e.g., no '=' or an empty part from '&&')
            raise ValueError(f"Malformed key-value pair encountered: '{pair_str}' in key_string '{key_string}'")
            
    return params



# --- Function to get hierarchical parameter options ---
def get_hierarchical_parameter_options(
    dict_of_all_plots: dict,
    key_order: list[str],
    current_selection: dict = None, # Internally used for recursion
    preserved_types_in_keys: bool = True
) -> dict:
    """
    Recursively discovers all available parameter options from dict_of_all_plots
    based on a specified key_order, forming a hierarchical tree of choices.

    Args:
        dict_of_all_plots (dict): The main dictionary where keys are generated
                                  strings (by key_generator) and values are plot data.
        key_order (list[str]): A list of parameter names defining the desired
                               hierarchy (e.g., ['dataset', 'algorithm', 'run_id']).
                               The order dictates the levels of the hierarchy.
        current_selection (dict, optional): Used internally for recursion.
                                            Represents parameters already chosen at
                                            higher levels of the hierarchy.
                                            Users typically call this with None or {}.
        preserved_types_in_keys (bool): Flag indicating if types were preserved
                                        during key generation (using repr()). This
                                        must match how keys were generated.
                                        Defaults to True.

    Returns:
        dict: A nested dictionary representing the hierarchy of available options.
              Keys at each level are the parameter values, and their values are
              sub-dictionaries for the next parameter in key_order. An empty
              dictionary as a value indicates a valid terminal choice for that path.
              Returns an empty dict if key_order is empty or no matching data.
    """
    if current_selection is None:
        current_selection = {}

    if not key_order: # Base case: no more keys in the hierarchy to process
        return {}

    current_param_name_to_find = key_order[0]
    remaining_key_order = key_order[1:]
    
    options_for_current_param_value = set()
    
    for key_str in dict_of_all_plots.keys():
        try:
            params_dict = reverse_key_generator(key_str, preserved_types=preserved_types_in_keys)
        except ValueError:
            continue 

        match_current_selection = True
        for sel_key, sel_value in current_selection.items():
            if params_dict.get(sel_key) != sel_value:
                match_current_selection = False
                break
        
        if match_current_selection:
            if current_param_name_to_find in params_dict:
                options_for_current_param_value.add(params_dict[current_param_name_to_find])

    try:
        sorted_unique_options = sorted(list(options_for_current_param_value))
    except TypeError:
        sorted_unique_options = sorted(list(options_for_current_param_value), key=str)

    result_hierarchy_for_this_level = {}
    for option_val in sorted_unique_options:
        new_selection_for_recursion = current_selection.copy()
        new_selection_for_recursion[current_param_name_to_find] = option_val
        
        sub_options_tree = get_hierarchical_parameter_options(
            dict_of_all_plots,
            remaining_key_order, 
            new_selection_for_recursion, 
            preserved_types_in_keys
        )
        result_hierarchy_for_this_level[option_val] = sub_options_tree
            
    return result_hierarchy_for_this_level

# --- New function to get all distinct parameter values (non-hierarchical) ---
def get_all_distinct_parameter_values(
    dict_of_all_plots: dict,
    parameter_names_of_interest: list[str],
    preserved_types_in_keys: bool = True
) -> dict:
    """
    Finds all unique values for each specified parameter name across all
    plot data entries. This is non-hierarchical.

    Args:
        dict_of_all_plots (dict): The main dictionary where keys are generated
                                  strings (by key_generator) and values are plot data.
        parameter_names_of_interest (list[str]): A list of parameter names for
                                                 which to find all distinct values.
        preserved_types_in_keys (bool): Flag indicating if types were preserved
                                        during key generation. Defaults to True.

    Returns:
        dict: A dictionary where keys are the parameter names from
              parameter_names_of_interest and values are sorted lists of
              their unique observed values. If a parameter name is not found
              in any of the data, its list will be empty.
    """
    if not parameter_names_of_interest:
        return {}

    # Initialize a dictionary to hold sets of unique values for each parameter
    distinct_values_map = {param_name: set() for param_name in parameter_names_of_interest}

    for key_str in dict_of_all_plots.keys():
        try:
            # Reverse the stored string key back into a parameter dictionary
            params_dict = reverse_key_generator(key_str, preserved_types=preserved_types_in_keys)
        except ValueError:
            # Skip malformed keys
            # print(f"Warning: Skipping malformed key: {key_str}")
            continue
        
        # For each parameter we are interested in, check if it exists in the current params_dict
        for param_name in parameter_names_of_interest:
            if param_name in params_dict:
                distinct_values_map[param_name].add(params_dict[param_name])

    # Convert sets to sorted lists for the final output
    result = {}
    for param_name, values_set in distinct_values_map.items():
        try:
            # Attempt to sort directly
            result[param_name] = sorted(list(values_set))
        except TypeError:
            # Fallback if types are mixed or unhashable (e.g., [1, 'a', True])
            # Sort by their string representation
            result[param_name] = sorted(list(values_set), key=str)
            
    return result